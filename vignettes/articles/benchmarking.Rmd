---
title: "Benchmarking"
date: 'June 06, 2025'
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float:
      collapsed: false
      toc_levels: 2
    number_sections: true
    highlight: zenburn
    code_folding: show
    fig_caption: true
    df_print: paged 
---

<-- This is a precomputing script. To run it, `knitr::knit("vignettes/articles/benchmarking_orig.Rmd.orig", output = "vignettes/articles/benchmarking.Rmd")` -->

<style>
p.caption {
  font-size: 0.6em;
  text-align: "center";
}
</style>



# DISCLAIMER

The present benchmark was conducted on 2025-06-06 on a Macbook Pro M4 (12-core CPU, 16-core GPU, 24GB RAM). Results _will_ vary depending on the hardware. The benchmarks are intended to provide a general idea of the performance differences between the `fio` package and other implementations, but they should not be considered definitive. The performance of the functions may also vary depending on the specific data used and the context in which the functions are applied.

# Introduction

This vignette presents a benchmarking analysis comparing the performance of functions from the `fio` package with equivalent base R functions. The `fio` package provides a set of functions for input-output analysis, a method used in economics to analyze the interdependencies between different sectors of an economy.

In this document, we will focus on two key functions: the technical coefficients matrix calculation and the Leontief inverse matrix calculation. These functions are fundamental to input-output analysis, and their performance can significantly impact the speed of larger analyses.

Our benchmarking tests, which involve running these functions repeatedely in simulated datasets, show that the `fio` package functions are faster than other implementations. This improved performance can make a substantial difference in larger analyses, making the `fio` package a valuable tool for input-output analysis in R.

The tests were run on a simulated $2000 \times 2000$ matrix, and each test was repeated 100 times to account for variability. Please note that the results of this benchmarking analysis are dependent on the specific test datasets used and the hardware on which the algorithms were run. Therefore, the results should be interpreted in the context of these specific conditions.

# Technical coefficients matrix

The technical coefficients matrix calculation, a key and initial step in input-output analysis, was tested using the `compute_tech_coeff()` function from the `{fio}` package, equivalent functions from the `{leontief}` package, and a base R implementation. It consists on dividing each $a_{ij}$ element of intermediate transactions matrix by the correspondent $x_j$ element of total production vector^[Or in a equivalent way, multiplying intermediate transactions matrix by a diagonal matrix constructed from total production vector.].


``` r
# set seed
set.seed(100)

# data
matrix_dim <- 2000
intermediate_transactions <- matrix(
  as.double(sample(1:1000, matrix_dim^2, replace = TRUE)),
  nrow = matrix_dim,
  ncol = matrix_dim
)
total_production <- matrix(
  as.double(sample(4000000:6000000, matrix_dim, replace = TRUE)),
  nrow = 1,
  ncol = matrix_dim
)

# Base R function
tech_coeff_r <- function(intermediate_transactions, total_production) {
  tech_coeff_matrix <- intermediate_transactions %*% diag(1 / as.vector(total_production))
  return(tech_coeff_matrix)
}

# {fio} setup
iom_fio <- fio::iom$new("iom", intermediate_transactions, total_production)

# benchmark
benchmark_a <- microbenchmark::microbenchmark(
  fio = fio:::compute_tech_coeff(intermediate_transactions, total_production),
  `Base R` = tech_coeff_r(intermediate_transactions, total_production),
  leontief = leontief::input_requirement(intermediate_transactions, total_production),
  times = 100
)
print(benchmark_a)
#> Unit: milliseconds
#>      expr         min         lq       mean     median         uq        max
#>       fio    9.227378   10.59014   12.32820   11.00756   12.10187   41.55916
#>    Base R 1881.959409 1973.27830 1983.37769 1995.08118 2004.39316 2028.18944
#>  leontief   34.150253   36.90681   49.15617   40.84664   63.28766   70.77965
#>  neval
#>    100
#>    100
#>    100

# plot
ggplot2::autoplot(benchmark_a)
```

<div class="figure" style="text-align: center">
<img src="figure/benchmark_a-1.png" alt="\label{fig:benchmark_a}{fio} is faster."  />
<p class="caption">\label{fig:benchmark_a}{fio} is faster.</p>
</div>

# Leontief inverse matrix

When we're talking about inverting a $2000 \times 2000$ there's a lot more work involved. Leontief matrix ($L$) is obtained from subtracting the technical coefficients matrix ($A$) from the identity matrix ($I$), therefore it has no null rows or columns. 

$$L = I - A$$

It allows for solving the linear system through LU decomposition, which is a more efficient method than the direct inverse matrix calculation.


``` r
# data
iom_fio$compute_tech_coeff()
technical_coefficients_matrix <- iom_fio$technical_coefficients_matrix

# base R function
leontief_inverse_r <- function(technical_coefficients_matrix) {
  dim <- nrow(technical_coefficients_matrix)
  leontief_inverse_matrix <- solve(diag(dim) - technical_coefficients_matrix)
  return(leontief_inverse_matrix)
}

# benchmark
benchmark_b <- microbenchmark::microbenchmark(
  fio = fio:::compute_leontief_inverse(technical_coefficients_matrix),
  `Base R` = leontief_inverse_r(technical_coefficients_matrix),
  leontief = leontief::leontief_inverse(technical_coefficients_matrix),
  times = 100
)
print(benchmark_b)
#> Unit: milliseconds
#>      expr       min        lq      mean    median        uq        max neval
#>       fio  123.4593  128.8462  165.7808  131.4057  136.4588   660.5447   100
#>    Base R 2299.2996 2307.4041 3012.2608 2312.4703 2362.0039 13355.7520   100
#>  leontief 2301.8362 2306.7297 2604.8781 2309.6734 2333.0734 12778.9560   100

# plot
ggplot2::autoplot(benchmark_b)
```

<div class="figure" style="text-align: center">
<img src="figure/benchmark_b-1.png" alt="\label{fig:figs} {fio} is incredibly faster."  />
<p class="caption">\label{fig:figs} {fio} is incredibly faster.</p>
</div>

# Sensitivity of dispersion coefficients of variation

To represent linkage-based functions performance, we compute benchmark for sensitivity of dispersion coefficients of variation.


``` r
# data
iom_fio$compute_leontief_inverse()
leontief_inverse_matrix <- iom_fio$leontief_inverse_matrix

# base R function
sensitivity_r <- function(B) {
  n <- nrow(B)
  SL = rowSums(B)
  ML = SL / n
  (((1 / (n - 1)) * (colSums((B - ML) ** 2))) ** 0.5) / ML
}

# benchmark
benchmark_c <- microbenchmark::microbenchmark(
  fio = fio:::compute_sensitivity_dispersion_cv(leontief_inverse_matrix),
  `Base R` = sensitivity_r(leontief_inverse_matrix),
  leontief = leontief::sensitivity_dispersion_cv(leontief_inverse_matrix),
  times = 100
)
print(benchmark_c)
#> Unit: milliseconds
#>      expr        min         lq       mean     median         uq        max
#>       fio   5.009339   5.272210   5.707487   5.808962   5.947563   7.477908
#>    Base R   7.331374   7.578727   9.155474   7.792624   7.946743  39.151310
#>  leontief 284.126433 318.893961 322.455093 321.330243 324.001373 767.253582
#>  neval
#>    100
#>    100
#>    100
ggplot2::autoplot(benchmark_c)
```

<div class="figure" style="text-align: center">
<img src="figure/benchmark_c-1.png" alt="\label{fig:benchmark_c} {fio} again faster."  />
<p class="caption">\label{fig:benchmark_c} {fio} again faster.</p>
</div>

# Field of influence

Since field of influence involves computing Leontief inverse matrix for each element of technical coefficients matrix after an increment, it can be demanding for high dimensional matrices. Here, we evaluate benchmark for base R function and {fio}, since there's no similiar function in {leontief}. For brevity, we cut dimensions to 100 and repetitions to 10.


``` r
# data
matrix_dim <- 100
intermediate_transactions <- matrix(
  as.double(sample(1:1000, matrix_dim^2, replace = TRUE)),
  nrow = matrix_dim,
  ncol = matrix_dim
)
total_production <- matrix(
  as.double(sample(4000000:6000000, matrix_dim, replace = TRUE)),
  nrow = 1,
  ncol = matrix_dim
)
iom_fio_reduced <- fio::iom$new(
  "iom_reduced",
  intermediate_transactions,
  total_production
)$compute_tech_coeff()$compute_leontief_inverse()

# base R function
field_influence_r <- function(A, B, ee = 0.001) {
  n = nrow(A)
  I = diag(n)
  E = matrix(0, ncol = n, nrow = n)
  SI = matrix(0, ncol = n, nrow = n)
  for (i in 1:n) {
    for (j in 1:n) {
      E[i, j] = ee
      AE = A + E
      BE = solve(I - AE)
      FE = (BE - B) / ee
      FEq = FE * FE
      S = sum(FEq)
      SI[i, j] = S
      E[i, j] = 0
    }
  }
}

# benchmark
benchmark_d <- microbenchmark::microbenchmark(
  fio = fio:::compute_field_influence(
    iom_fio_reduced$technical_coefficients_matrix,
    iom_fio_reduced$leontief_inverse_matrix,
    0.001
  ),
  `Base R` = field_influence_r(iom_fio_reduced$technical_coefficients_matrix, iom_fio_reduced$leontief_inverse_matrix),
  times = 10
)
print(benchmark_d)
#> Unit: seconds
#>    expr      min       lq     mean   median       uq      max neval
#>     fio 2.032791 2.414959 5.583490 2.990123 3.750655 18.25428    10
#>  Base R 4.405828 4.423133 7.659431 4.459804 7.651292 21.86961    10
ggplot2::autoplot(benchmark_d)
```

<div class="figure" style="text-align: center">
<img src="figure/benchmark_d-1.png" alt="\label{fig:benchmark_d} {fio} faster."  />
<p class="caption">\label{fig:benchmark_d} {fio} faster.</p>
</div>
