---
title: "Benchmarking"
date: 'June 16, 2025'
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float:
      collapsed: false
      toc_levels: 2
    number_sections: true
    highlight: zenburn
    code_folding: show
    fig_caption: true
    df_print: paged 
---

<!-- This is a precomputing script. To run it, `knitr::knit("vignettes/articles/benchmarking_orig.Rmd.orig", output = "vignettes/articles/benchmarking.Rmd")` -->

<style>
p.caption {
  font-size: 0.6em;
  text-align: "center";
}
</style>



# DISCLAIMER

The present benchmark was conducted on 2025-06-16 on a Macbook Pro M4 (12-core CPU, 16-core GPU, 24GB RAM). Results _will_ vary depending on the hardware. These benchmarks aim to provide a general idea of the performance differences between the `fio` package and other implementations but should not be considered definitive. The performance of the functions may also vary depending on the specific data used and the context in which they are applied.

# Introduction

This vignette presents a benchmarking analysis comparing the performance of functions from the `fio` package with equivalent base R functions and functions from other packages. The `fio` package provides a set of functions for input-output analysis, a method used in economics to analyze the interdependencies between different sectors of an economy.

Our benchmarking tests show that `fio` package functions are either faster or more memory-efficient than other implementations. This improved performance can make a substantial difference in larger analyses, making the `fio` package a valuable tool for input-output analysis in R.

The tests were run on simulated square matrices, with dimensions ranging from 100x100 up to 2000x2000, and each test was repeated at least 10 times to account for variability. Please note that the results of this benchmarking analysis depend on the specific test datasets used and the hardware on which the algorithms were run. Therefore, the results should be interpreted in the context of these specific conditions.

# Technical coefficients matrix

The technical coefficients matrix calculation, a key and initial step in input-output analysis, was tested using the `compute_tech_coeff()` function from the `{fio}` package, equivalent functions from the `{leontief}` package, and a base R implementation. It consists of dividing each $a_{ij}$ element of the intermediate transactions matrix by the corresponding $x_j$ element of the total production vector^[Or equivalently, multiplying the intermediate transactions matrix by a diagonal matrix constructed from the total production vector.].

Results shows that {fio} is generally faster and uses significantly less memory than the other two implementations, especially for larger matrices (≥500x500). The memory usage of {fio} is approximately half that of Base R and 12% of that used by {leontief}.


``` r
# set seed
set.seed(100)

# Base R function
tech_coeff_r <- function(intermediate_transactions, total_production) {
  tech_coeff_matrix <- intermediate_transactions %*% diag(1 / as.vector(total_production))
  return(tech_coeff_matrix)
}

# benchmark
benchmark_a <- bench::press(
  matrix_dim = c(100, 500, 1000, 2000),
  {
    intermediate_transactions <- matrix(
      as.double(sample(1:1000, matrix_dim^2, replace = TRUE)),
      nrow = matrix_dim,
      ncol = matrix_dim
    )
    total_production <- matrix(
      as.double(sample(4000000:6000000, matrix_dim, replace = TRUE)),
      nrow = 1,
      ncol = matrix_dim
    )
    iom_fio <- fio::iom$new("iom", intermediate_transactions, total_production)
    bench::mark(
      fio = fio:::compute_tech_coeff(intermediate_transactions, total_production),
      `Base R` = tech_coeff_r(intermediate_transactions, total_production),
      leontief = leontief::input_requirement(intermediate_transactions, total_production),
      iterations = 100
    )
  }
)
#> Running with:
#>   matrix_dim
#> 1        100
#> 2        500
#> 3       1000
#> 4       2000
print(benchmark_a)
#> # A tibble: 12 × 14
#>    expression matrix_dim      min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time result                memory                 time             gc                
#>    <bch:expr>      <dbl> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm> <list>                <list>                 <list>           <list>            
#>  1 fio               100   50.1µs  77.22µs   11997.   861.83KB      0     100     0     8.34ms <dbl [100 × 100]>     <Rprofmem [6 × 3]>     <bench_tm [100]> <tibble [100 × 3]>
#>  2 Base R            100  55.64µs  82.51µs   10885.   190.65KB      0     100     0     9.19ms <dbl [100 × 100]>     <Rprofmem [12 × 3]>    <bench_tm [100]> <tibble [100 × 3]>
#>  3 leontief          100  141.2µs 161.21µs    6124.   706.38KB     61.9    99     1    16.17ms <dbl [100 × 100]>     <Rprofmem [352 × 3]>   <bench_tm [100]> <tibble [100 × 3]>
#>  4 fio               500 371.67µs 661.95µs    1444.     1.91MB     60.2    96     4    66.48ms <dbl [500 × 500]>     <Rprofmem [1 × 3]>     <bench_tm [100]> <tibble [100 × 3]>
#>  5 Base R            500   1.02ms   1.25ms     780.     3.82MB     96.4    89    11   114.07ms <dbl [500 × 500]>     <Rprofmem [3 × 3]>     <bench_tm [100]> <tibble [100 × 3]>
#>  6 leontief          500   1.98ms   2.36ms     422.    16.29MB    734.     38    66    89.98ms <dbl [500 × 500]>     <Rprofmem [1,509 × 3]> <bench_tm [100]> <tibble [100 × 3]>
#>  7 fio              1000   1.81ms   2.48ms     384.     7.63MB     78.6    83    17   216.22ms <dbl [1,000 × 1,000]> <Rprofmem [1 × 3]>     <bench_tm [100]> <tibble [100 × 3]>
#>  8 Base R           1000    6.6ms   7.99ms     124.    15.27MB     70.0    64    36   514.21ms <dbl [1,000 × 1,000]> <Rprofmem [3 × 3]>     <bench_tm [100]> <tibble [100 × 3]>
#>  9 leontief         1000   9.66ms  10.15ms     100.       65MB   4971.      3   149    29.98ms <dbl [1,000 × 1,000]> <Rprofmem [3,009 × 3]> <bench_tm [100]> <tibble [100 × 3]>
#> 10 fio              2000  10.82ms  11.59ms      83.5   30.52MB     34.1    71    29   850.67ms <dbl [2,000 × 2,000]> <Rprofmem [1 × 3]>     <bench_tm [100]> <tibble [100 × 3]>
#> 11 Base R           2000  47.07ms  51.94ms      19.2   61.05MB     35.7    35    65      1.82s <dbl [2,000 × 2,000]> <Rprofmem [3 × 3]>     <bench_tm [100]> <tibble [100 × 3]>
#> 12 leontief         2000   36.2ms  36.92ms      27.0   259.7MB   1263.      4   187   148.01ms <dbl [2,000 × 2,000]> <Rprofmem [6,009 × 3]> <bench_tm [100]> <tibble [100 × 3]>

# plot
ggplot2::autoplot(benchmark_a)
```

<div class="figure" style="text-align: center">
<img src="figure/benchmark_a-1.png" alt="\label{fig:benchmark_a} For larger matrices (≥500x500), {fio} is generally faster and uses significantly less memory: approximately half that of Base R and 12% of that used by {leontief}."  />
<p class="caption">\label{fig:benchmark_a} For larger matrices (≥500x500), {fio} is generally faster and uses significantly less memory: approximately half that of Base R and 12% of that used by {leontief}.</p>
</div>

# Leontief inverse matrix

The Leontief matrix ($L$) is obtained by subtracting the technical coefficients matrix ($A$) from the identity matrix ($I$); therefore, it has no null rows or columns. This allows for solving the linear system $L \times L^{-1} = I$ through LU decomposition, which is a more efficient method than direct inverse matrix calculation.

Results shows that execution times are comparable across methods, with {fio} demonstrating superior memory efficiency, using less than half the memory of alternatives.


``` r
# base R function
leontief_inverse_r <- function(technical_coefficients_matrix) {
  dim <- nrow(technical_coefficients_matrix)
  leontief_inverse_matrix <- solve(diag(dim) - technical_coefficients_matrix)
  return(leontief_inverse_matrix)
}

# benchmark
benchmark_b <- bench::press(
  matrix_dim = c(100, 500, 1000, 2000),
  {
    intermediate_transactions <- matrix(
      as.double(sample(1:1000, matrix_dim^2, replace = TRUE)),
      nrow = matrix_dim,
      ncol = matrix_dim
    )
    total_production <- matrix(
      as.double(sample(4000000:6000000, matrix_dim, replace = TRUE)),
      nrow = 1,
      ncol = matrix_dim
    )
    iom_fio <- fio::iom$new("iom", intermediate_transactions, total_production)
    iom_fio$compute_tech_coeff()
    technical_coefficients_matrix <- iom_fio$technical_coefficients_matrix
    bench::mark(
      fio = fio:::compute_leontief_inverse(technical_coefficients_matrix),
      `Base R` = leontief_inverse_r(technical_coefficients_matrix),
      leontief = leontief::leontief_inverse(technical_coefficients_matrix),
      iterations = 100,
      check = FALSE
    )
  }
)
#> Running with:
#>   matrix_dim
#> 1        100
#> 2        500
#> 3       1000
#> 4       2000
print(benchmark_b)
#> # A tibble: 12 × 14
#>    expression matrix_dim      min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time result memory              time             gc                
#>    <bch:expr>      <dbl> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm> <list> <list>              <list>           <list>            
#>  1 fio               100 106.48µs 135.14µs    4168.   158.51KB     0      100     0    23.99ms <NULL> <Rprofmem [6 × 3]>  <bench_tm [100]> <tibble [100 × 3]>
#>  2 Base R            100 268.59µs 367.15µs    2750.   413.27KB     0      100     0    36.36ms <NULL> <Rprofmem [20 × 3]> <bench_tm [100]> <tibble [100 × 3]>
#>  3 leontief          100 274.99µs 361.52µs    2832.   402.57KB     0      100     0    35.31ms <NULL> <Rprofmem [15 × 3]> <bench_tm [100]> <tibble [100 × 3]>
#>  4 fio               500   3.39ms   4.14ms     236.     3.81MB     4.81    98     2   415.45ms <NULL> <Rprofmem [2 × 3]>  <bench_tm [100]> <tibble [100 × 3]>
#>  5 Base R            500   3.95ms    4.3ms     231.     9.55MB     9.61    96     4   416.13ms <NULL> <Rprofmem [7 × 3]>  <bench_tm [100]> <tibble [100 × 3]>
#>  6 leontief          500   4.04ms   4.36ms     222.     9.55MB     6.87    97     3   436.57ms <NULL> <Rprofmem [8 × 3]>  <bench_tm [100]> <tibble [100 × 3]>
#>  7 fio              1000  15.38ms  17.82ms      56.1   15.26MB     2.34    96     4      1.71s <NULL> <Rprofmem [2 × 3]>  <bench_tm [100]> <tibble [100 × 3]>
#>  8 Base R           1000  17.05ms  17.59ms      56.6   38.18MB    14.2     80    20      1.41s <NULL> <Rprofmem [7 × 3]>  <bench_tm [100]> <tibble [100 × 3]>
#>  9 leontief         1000  16.97ms  17.55ms      56.4   38.18MB    14.1     80    20      1.42s <NULL> <Rprofmem [7 × 3]>  <bench_tm [100]> <tibble [100 × 3]>
#> 10 fio              2000  79.96ms  88.73ms      11.1   61.03MB     1.96    85    15      7.67s <NULL> <Rprofmem [2 × 3]>  <bench_tm [100]> <tibble [100 × 3]>
#> 11 Base R           2000   84.6ms  85.88ms      11.6  152.66MB   140.       8    97   691.22ms <NULL> <Rprofmem [7 × 3]>  <bench_tm [100]> <tibble [100 × 3]>
#> 12 leontief         2000  84.65ms  88.03ms      11.4  152.66MB   160.       7    98   611.96ms <NULL> <Rprofmem [7 × 3]>  <bench_tm [100]> <tibble [100 × 3]>

# plot
ggplot2::autoplot(benchmark_b)
```

<div class="figure" style="text-align: center">
<img src="figure/benchmark_b-1.png" alt="\label{fig:figs} While execution times are comparable across methods, {fio} demonstrates superior memory efficiency, using less than half the memory of alternatives for matrices 500x500 and larger."  />
<p class="caption">\label{fig:figs} While execution times are comparable across methods, {fio} demonstrates superior memory efficiency, using less than half the memory of alternatives for matrices 500x500 and larger.</p>
</div>

# Sensitivity of dispersion coefficients of variation

To evaluate the performance of linkage-based functions, we benchmarked the sensitivity of dispersion coefficients of variation.

Results shows that {fio} is substantially faster and more memory-efficient than {leontief} across all tested dimensions. Compared to Base R, {fio} is faster for matrices 1000x1000 and larger, while memory usage remains comparable.


``` r
# base R function
sensitivity_r <- function(B) {
  n <- nrow(B)
  SL = rowSums(B)
  ML = SL / n
  (((1 / (n - 1)) * (colSums((B - ML) ** 2))) ** 0.5) / ML
}

# benchmark
benchmark_c <- bench::press(
  matrix_dim = c(100, 500, 1000, 2000),
  {
    intermediate_transactions <- matrix(
      as.double(sample(1:1000, matrix_dim^2, replace = TRUE)),
      nrow = matrix_dim,
      ncol = matrix_dim
    )
    total_production <- matrix(
      as.double(sample(4000000:6000000, matrix_dim, replace = TRUE)),
      nrow = 1,
      ncol = matrix_dim
    )
    iom_fio <- fio::iom$new("iom", intermediate_transactions, total_production)
    iom_fio$compute_tech_coeff()$compute_leontief_inverse()
    leontief_inverse_matrix <- iom_fio$leontief_inverse_matrix
    bench::mark(
      fio = fio:::compute_sensitivity_dispersion_cv(leontief_inverse_matrix),
      `Base R` = sensitivity_r(leontief_inverse_matrix),
      leontief = leontief::sensitivity_dispersion_cv(leontief_inverse_matrix),
      iterations = 100,
      check = FALSE
    )
  }
)
#> Running with:
#>   matrix_dim
#> 1        100
#> 2        500
#> 3       1000
#> 4       2000
#> Warning: Some expressions had a GC in every iteration; so filtering is disabled.
print(benchmark_c)
#> # A tibble: 12 × 14
#>    expression matrix_dim      min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time result memory                  time             gc                
#>    <bch:expr>      <dbl> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm> <list> <list>                  <list>           <list>            
#>  1 fio               100 123.04µs 201.88µs   4828.     81.23KB     0      100     0    20.71ms <NULL> <Rprofmem [6 × 3]>      <bench_tm [100]> <tibble [100 × 3]>
#>  2 Base R            100  21.73µs  25.81µs  18133.     81.48KB     0      100     0     5.51ms <NULL> <Rprofmem [5 × 3]>      <bench_tm [100]> <tibble [100 × 3]>
#>  3 leontief          100 507.01µs  561.5µs   1782.    745.38KB    18.0     99     1    55.56ms <NULL> <Rprofmem [522 × 3]>    <bench_tm [100]> <tibble [100 × 3]>
#>  4 fio               500 429.23µs 595.91µs   1671.      1.91MB     0      100     0    59.84ms <NULL> <Rprofmem [2 × 3]>      <bench_tm [100]> <tibble [100 × 3]>
#>  5 Base R            500 525.37µs 553.89µs   1801.      1.92MB     0      100     0    55.54ms <NULL> <Rprofmem [5 × 3]>      <bench_tm [100]> <tibble [100 × 3]>
#>  6 leontief          500  10.45ms  11.21ms     88.9    17.31MB     6.69    93     7      1.05s <NULL> <Rprofmem [2,513 × 3]>  <bench_tm [100]> <tibble [100 × 3]>
#>  7 fio              1000   1.47ms   1.66ms    589.      7.64MB     0      100     0   169.65ms <NULL> <Rprofmem [2 × 3]>      <bench_tm [100]> <tibble [100 × 3]>
#>  8 Base R           1000   1.79ms   2.13ms    468.      7.66MB    14.5     97     3   207.23ms <NULL> <Rprofmem [5 × 3]>      <bench_tm [100]> <tibble [100 × 3]>
#>  9 leontief         1000  60.99ms  63.03ms     15.9    68.94MB     4.22    79    21      4.97s <NULL> <Rprofmem [5,013 × 3]>  <bench_tm [100]> <tibble [100 × 3]>
#> 10 fio              2000   5.03ms   5.19ms    191.     30.53MB     0      100     0    522.2ms <NULL> <Rprofmem [2 × 3]>      <bench_tm [100]> <tibble [100 × 3]>
#> 11 Base R           2000   8.14ms   8.35ms    108.     30.58MB    16.1    100    15   929.67ms <NULL> <Rprofmem [5 × 3]>      <bench_tm [100]> <tibble [100 × 3]>
#> 12 leontief         2000  295.5ms 299.92ms      3.27  275.22MB     3.27   100   100     30.54s <NULL> <Rprofmem [10,013 × 3]> <bench_tm [100]> <tibble [100 × 3]>
ggplot2::autoplot(benchmark_c)
```

<div class="figure" style="text-align: center">
<img src="figure/benchmark_c-1.png" alt="\label{fig:benchmark_c} {fio} is substantially faster and more memory-efficient than {leontief} across all tested dimensions. Compared to Base R, {fio} is faster for matrices 1000x1000 and larger, while memory usage remains comparable."  />
<p class="caption">\label{fig:benchmark_c} {fio} is substantially faster and more memory-efficient than {leontief} across all tested dimensions. Compared to Base R, {fio} is faster for matrices 1000x1000 and larger, while memory usage remains comparable.</p>
</div>

# Field of influence

Since computing the field of influence involves calculating the Leontief inverse matrix for each element of the technical coefficients matrix after an increment, it can be demanding for high-dimensional matrices. Here, we benchmark the base R function and `{fio}`, as there is no similar function in `{leontief}`. For brevity, we limited the matrix dimensions to 100x100 and the number of repetitions to 10.

Results shows that {fio} is almost two times faster than the base R implementation and uses significantly less memory. For the 100x100 matrix, {fio} used 156.34KB, while the base R implementation used 5.25GB, which would lead to memory issues for larger matrices and would make it impractical for real-world applications, specially in personal computers with limited memory.


``` r
# base R function
field_influence_r <- function(A, B, ee = 0.001) {
  n = nrow(A)
  I = diag(n)
  E = matrix(0, ncol = n, nrow = n)
  SI = matrix(0, ncol = n, nrow = n)
  for (i in 1:n) {
    for (j in 1:n) {
      E[i, j] = ee
      AE = A + E
      BE = solve(I - AE)
      FE = (BE - B) / ee
      FEq = FE * FE
      S = sum(FEq)
      SI[i, j] = S
      E[i, j] = 0
    }
  }
  return(SI) # Added return statement
}

# benchmark
benchmark_d <- bench::press(
  matrix_dim = c(30, 60, 100),
  {
    intermediate_transactions <- matrix(
      as.double(sample(1:1000, matrix_dim^2, replace = TRUE)),
      nrow = matrix_dim,
      ncol = matrix_dim
    )
    total_production <- matrix(
      as.double(sample(4000000:6000000, matrix_dim, replace = TRUE)),
      nrow = 1,
      ncol = matrix_dim
    )
    iom_fio_reduced <- fio::iom$new(
      "iom_reduced",
      intermediate_transactions,
      total_production
    )$compute_tech_coeff()$compute_leontief_inverse()
    bench::mark(
      fio = fio:::compute_field_influence(
        iom_fio_reduced$technical_coefficients_matrix,
        iom_fio_reduced$leontief_inverse_matrix,
        0.001
      ),
      `Base R` = field_influence_r(
        iom_fio_reduced$technical_coefficients_matrix,
        iom_fio_reduced$leontief_inverse_matrix
      ),
      iterations = 10,
      check = FALSE
    )
  }
)
#> Running with:
#>   matrix_dim
#> 1         30
#> 2         60
#> Warning: Some expressions had a GC in every iteration; so filtering is disabled.
#> 3        100
#> Warning: Some expressions had a GC in every iteration; so filtering is disabled.
print(benchmark_d)
#> # A tibble: 6 × 14
#>   expression matrix_dim      min   median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time result memory                  time            gc               
#>   <bch:expr>      <dbl> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm> <list> <list>                  <list>          <list>           
#> 1 fio                30   5.48ms   5.51ms   180.      16.67KB     0       10     0     55.6ms <NULL> <Rprofmem [6 × 3]>      <bench_tm [10]> <tibble [10 × 3]>
#> 2 Base R             30  24.16ms  24.46ms    40.7     44.52MB    10.2      8     2   196.78ms <NULL> <Rprofmem [7,384 × 3]>  <bench_tm [10]> <tibble [10 × 3]>
#> 3 fio                60  111.3ms 111.69ms     8.93    56.34KB     0       10     0      1.12s <NULL> <Rprofmem [2 × 3]>      <bench_tm [10]> <tibble [10 × 3]>
#> 4 Base R             60 713.37ms 721.51ms     1.37    701.2MB     3.02    10    22      7.28s <NULL> <Rprofmem [32,403 × 3]> <bench_tm [10]> <tibble [10 × 3]>
#> 5 fio               100    1.64s    2.39s     0.414  156.34KB     0       10     0     24.13s <NULL> <Rprofmem [2 × 3]>      <bench_tm [10]> <tibble [10 × 3]>
#> 6 Base R            100    4.21s    4.26s     0.234    5.25GB     4.35    10   186     42.78s <NULL> <Rprofmem [90,003 × 3]> <bench_tm [10]> <tibble [10 × 3]>
ggplot2::autoplot(benchmark_d)
```

<div class="figure" style="text-align: center">
<img src="figure/benchmark_d-1.png" alt="\label{fig:benchmark_d} Across all matrix sizes, {fio} demonstrates superior performance, being considerably faster and more memory-efficient than the Base R implementation."  />
<p class="caption">\label{fig:benchmark_d} Across all matrix sizes, {fio} demonstrates superior performance, being considerably faster and more memory-efficient than the Base R implementation.</p>
</div>
